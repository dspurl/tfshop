"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculatePadding = void 0;
var util_1 = require("@antv/util");
var constant_1 = require("../../constant");
var bbox_1 = require("../../util/bbox");
var padding_1 = require("../../util/padding");
var padding_cal_1 = require("./padding-cal");
/**
 * @ignore
 * 根据 view 中的组件，计算实际的 padding 数值
 * @param view
 */
function calculatePadding(view) {
    var padding = view.padding;
    // 如果不是 auto padding，那么直接解析之后返回
    if (!padding_1.isAutoPadding(padding)) {
        return padding_1.parsePadding(padding);
    }
    // 是 auto padding，根据组件的情况，来计算 padding
    var viewBBox = view.viewBBox, autoPadding = view.autoPadding;
    var paddingCal = new padding_cal_1.PaddingCal();
    util_1.each(view.getComponents(), function (co) {
        var component = co.component, type = co.type;
        // grid, tooltip 不参入 padding 布局
        if (type === constant_1.COMPONENT_TYPE.GRID || type === constant_1.COMPONENT_TYPE.TOOLTIP) {
            return;
        }
        var bboxObject = component.getLayoutBBox();
        var componentBBox = new bbox_1.BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
        if (type === constant_1.COMPONENT_TYPE.AXIS) {
            var exceed = componentBBox.exceed(viewBBox);
            paddingCal.shrink(exceed);
        }
        else {
            // 按照方向计算 padding
            var direction = co.direction;
            // const direction =
            //   type === COMPONENT_TYPE.AXIS ? getTranslateDirection(co.direction, view.getCoordinate()) : co.direction;
            paddingCal.inc(componentBBox, direction);
        }
    });
    var calculatedPadding = paddingCal.getPadding();
    if (autoPadding) {
        var appendPadding = padding_1.parsePadding(view.appendPadding);
        // 取上一次以及当前计算结果的最大区间
        return [
            Math.max(autoPadding[0] - appendPadding[0], calculatedPadding[0]),
            Math.max(autoPadding[1] - appendPadding[1], calculatedPadding[1]),
            Math.max(autoPadding[2] - appendPadding[2], calculatedPadding[2]),
            Math.max(autoPadding[3] - appendPadding[3], calculatedPadding[3]),
        ];
    }
    return calculatedPadding;
}
exports.calculatePadding = calculatePadding;
//# sourceMappingURL=auto.js.map