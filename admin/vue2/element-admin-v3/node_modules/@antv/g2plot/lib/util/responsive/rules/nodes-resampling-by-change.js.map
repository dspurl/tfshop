{"version":3,"file":"nodes-resampling-by-change.js","sourceRoot":"","sources":["../../../../src/util/responsive/rules/nodes-resampling-by-change.ts"],"names":[],"mappings":";;;AACA,mCAAqC;AACrC,kEAAmC;AAEnC,iCAAiC;AACjC,SAAwB,uBAAuB,CAAC,KAAa,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;IAC/E,IAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC;IAC9B,IAAM,SAAS,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;IAC5C,IAAI,KAAK,IAAI,CAAC,EAAE;QACd,OAAO;KACR;IACD,IAAM,OAAO,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;IAC7B,mCAAmC;IACnC,IAAM,QAAQ,GAAG,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAC5C,IAAM,KAAK,GAAG,QAAQ,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IACjD,IAAM,KAAK,GAAG,QAAQ,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IACjD,IAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,CAAC;IACtD,IAAI,IAAI,GAAG,SAAS,EAAE;QACpB,mBAAQ,CAAC,KAAK,CAAC,CAAC;QAChB,KAAK,CAAC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;KAC1B;AACH,CAAC;AAhBD,0CAgBC;AAED,SAAS,YAAY,CAAC,KAAK,EAAE,KAAK;IAChC,KAAK,IAAI,CAAC,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;QAClC,IAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QACtB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;YAC5B,OAAO,IAAI,CAAC;SACb;KACF;AACH,CAAC;AAED,SAAS,kBAAkB,CAAC,KAAK;IAC/B,IAAM,UAAU,GAAG,cAAO,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;IACtC,UAAU,CAAC,IAAI,CAAC,UAAC,CAAC,EAAE,CAAC;QACnB,OAAO,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC;IAC3B,CAAC,CAAC,CAAC;IACH,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AACzC,CAAC","sourcesContent":["import { IShape } from '@antv/g-base';\nimport { deepMix } from '@antv/util';\nimport textHide from './text-hide';\n\n/** 根据变化进行抽样，保留变化较大的点，类似于点简化算法 */\nexport default function nodesResamplingByChange(shape: IShape, option, index, cfg) {\n  const nodes = cfg.nodes.nodes;\n  const tolerance = getGlobalTolerance(nodes);\n  if (index <= 1) {\n    return;\n  }\n  const current = nodes[index];\n  // const previous = nodes[index-1];\n  const previous = findPrevious(index, nodes);\n  const distX = previous.centerX - current.centerX;\n  const distY = previous.centerY - current.centerY;\n  const dist = Math.sqrt(distX * distX + distY * distY);\n  if (dist < tolerance) {\n    textHide(shape);\n    shape.set('blank', true);\n  }\n}\n\nfunction findPrevious(index, nodes) {\n  for (let i = index - 1; i > 0; i--) {\n    const node = nodes[i];\n    if (!node.shape.get('blank')) {\n      return node;\n    }\n  }\n}\n\nfunction getGlobalTolerance(nodes) {\n  const nodesClone = deepMix([], nodes);\n  nodesClone.sort((a, b) => {\n    return b.width - a.width;\n  });\n  return Math.round(nodesClone[0].width);\n}\n"]}