"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var matrix_util_1 = require("@antv/matrix-util");
var util_1 = require("@antv/util");
var base_1 = require("./base");
var OverlapUtil = require("./overlap");
var Line = /** @class */ (function (_super) {
    tslib_1.__extends(Line, _super);
    function Line() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Line.prototype.getDefaultCfg = function () {
        var cfg = _super.prototype.getDefaultCfg.call(this);
        return tslib_1.__assign(tslib_1.__assign({}, cfg), { type: 'line', locationType: 'region', 
            /**
             * 起始点, x, y
             * @type {object}
             */
            start: null, 
            /**
             * 结束点, x, y
             * @type {object}
             */
            end: null });
    };
    // 获取坐标轴线的 path
    Line.prototype.getLinePath = function () {
        var start = this.get('start');
        var end = this.get('end');
        var path = [];
        path.push(['M', start.x, start.y]);
        path.push(['L', end.x, end.y]);
        return path;
    };
    // 重新计算 layout bbox，考虑到 line 不显示
    Line.prototype.getInnerLayoutBBox = function () {
        var start = this.get('start');
        var end = this.get('end');
        var bbox = _super.prototype.getInnerLayoutBBox.call(this);
        var minX = Math.min(start.x, end.x, bbox.x);
        var minY = Math.min(start.y, end.y, bbox.y);
        var maxX = Math.max(start.x, end.x, bbox.maxX);
        var maxY = Math.max(start.y, end.y, bbox.maxY);
        return {
            x: minX,
            y: minY,
            minX: minX,
            minY: minY,
            maxX: maxX,
            maxY: maxY,
            width: maxX - minX,
            height: maxY - minY,
        };
    };
    Line.prototype.isVertical = function () {
        var start = this.get('start');
        var end = this.get('end');
        return util_1.isNumberEqual(start.x, end.x);
    };
    Line.prototype.isHorizontal = function () {
        var start = this.get('start');
        var end = this.get('end');
        return util_1.isNumberEqual(start.y, end.y);
    };
    Line.prototype.getTickPoint = function (tickValue) {
        var self = this;
        var start = self.get('start');
        var end = self.get('end');
        var regionX = end.x - start.x;
        var regionY = end.y - start.y;
        return {
            x: start.x + regionX * tickValue,
            y: start.y + regionY * tickValue,
        };
    };
    // 直线坐标轴下任一点的向量方向都相同
    Line.prototype.getSideVector = function (offset) {
        var axisVector = this.getAxisVector();
        var normal = matrix_util_1.vec2.normalize([0, 0], axisVector);
        var factor = this.get('verticalFactor');
        var verticalVector = [normal[1], normal[0] * -1]; // 垂直方向，逆时针方向
        return matrix_util_1.vec2.scale([0, 0], verticalVector, offset * factor);
    };
    // 获取坐标轴的向量
    Line.prototype.getAxisVector = function () {
        var start = this.get('start');
        var end = this.get('end');
        return [end.x - start.x, end.y - start.y];
    };
    Line.prototype.processOverlap = function (labelGroup) {
        var _this = this;
        var isVertical = this.isVertical();
        var isHorizontal = this.isHorizontal();
        // 非垂直，或者非水平时不处理遮挡问题
        if (!isVertical && !isHorizontal) {
            return;
        }
        var labelCfg = this.get('label');
        var titleCfg = this.get('title');
        var verticalLimitLength = this.get('verticalLimitLength');
        var labelOffset = labelCfg.offset;
        var limitLength = verticalLimitLength;
        var titleHeight = 0;
        var titleSpacing = 0;
        if (titleCfg) {
            titleHeight = titleCfg.style.fontSize;
            titleSpacing = titleCfg.spacing;
        }
        if (limitLength) {
            limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
        }
        var overlapOrder = this.get('overlapOrder');
        util_1.each(overlapOrder, function (name) {
            if (labelCfg[name]) {
                _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
            }
        });
        if (titleCfg) {
            // 调整 title 的 offset
            var bbox = labelGroup.getBBox();
            var length_1 = isVertical ? bbox.width : bbox.height;
            if (util_1.isNil(titleCfg.offset)) {
                // 如果用户没有设置 offset，则自动计算
                titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
            }
        }
    };
    Line.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {
        var _this = this;
        var isVertical = this.isVertical();
        var hasAdjusted = false;
        var util = OverlapUtil[name];
        if (value === true) {
            // 默认使用固定角度的旋转方案
            hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);
        }
        else if (util_1.isFunction(value)) {
            // 用户可以传入回调函数
            hasAdjusted = value(isVertical, labelGroup, limitLength);
        }
        else if (util[value]) {
            // 按照名称执行旋转函数
            hasAdjusted = util[value](isVertical, labelGroup, limitLength);
        }
        if (name === 'autoRotate') {
            // 文本旋转后，文本的对齐方式可能就不合适了
            if (hasAdjusted) {
                var labels = labelGroup.getChildren();
                var verticalFactor_1 = this.get('verticalFactor');
                util_1.each(labels, function (label) {
                    var textAlign = label.attr('textAlign');
                    if (textAlign === 'center') {
                        // 居中的文本需要调整旋转度
                        var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';
                        label.attr('textAlign', newAlign);
                    }
                });
            }
        }
        else if (name === 'autoHide') {
            var children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错
            util_1.each(children, function (label) {
                if (!label.get('visible')) {
                    if (_this.get('isRegister')) {
                        // 已经注册过了，则删除
                        _this.unregisterElement(label);
                    }
                    label.remove(); // 防止 label 数量太多，所以统一删除
                }
            });
        }
    };
    return Line;
}(base_1.default));
exports.default = Line;
//# sourceMappingURL=line.js.map